import os

#АЛГОРИТМ:
#1)Делим содержимое файла на две матрицы:                                            1.Сначала читаем 2 матрицы из файла..
#первая — «изображение» (большая матрица),                                           2.Считаем размеры и создаём пустой результат.
#вторая — «ядро» (маленькая матрица, фильтр).                                        3.«Рамка» ядра двигается по изображению.
#                                                                                    4.Для каждого положения ядра считаем сумму произведений.
#                                                                                    5.Сохраняем всё в выходной файл.

#Считаем размеры изображения:
#img_h = количество строк, img_w = количество столбцов.
#Считаем размеры ядра:
#k_h = строки ядра, k_w = столбцы ядра.

#Вычисление размера результата
#Так как падинг не используется и шаг = 1, ядро может полностью помещаться только внутри изображения.
#Размер результата определяется формулой:

#высота: out_h = img_h - k_h + 1

#ширина: out_w = img_w - k_w + 1

#Если ядро больше изображения — выбрасываем ошибку.
#Создаём пустую результирующую матрицу result размера out_h × out_w, заполненную нулями.

#Основной цикл свёртки
#Для каждой позиции (i, j) в результирующей матрице:
#берём окно исходного изображения размером, как ядро, начиная с (i, j);
#умножаем попарно элементы окна и ядра;
#складываем все эти произведения — получаем одно число.
#это число записываем в result[i][j].
#Так ядро «скользит» по изображению: каждый раз окно сдвигается на один элемент вправо/вниз.


def read_matrices_from_file():
    # путь к файлу matrix_input.txt рядом со скриптом
    script_dir = os.path.dirname(os.path.abspath(__file__))
    input_path = os.path.join(script_dir, 'matrix_input.txt')

    with open(input_path, 'r', encoding='utf-8') as file:
       lines = file.readlines() #считаваем все строки матриц

    blocks = ''.join(lines).strip().split('\n\n') #склеваем все матрицы в одной строку, убирает лишние пробелы/переводы строк с начала и конца всей строки, разбиваем матрицы
    matrices = []
    for block in blocks: #перебираем каждую матрицу по очереди
        rows = block.strip().split('\n') #Убираем лишние пробелы с краёв блока и делим по переводам строки.
        matrix = [list(map(int, row.split())) for row in rows] #делим строку на список, каждую строку превращает в число и в конце делаем список
        matrices.append(matrix) #Добавляем готовую матрицу (список списков) в общий список.

    if len(matrices) != 2: #проверям что у нас в файле именно 2 матрицы
        raise ValueError("Файл должен содержать ровно две матрицы")

    return matrices[0], matrices[1]

def convolution_operation (image, kernel): #image — «большая» матрица (например, изображение), список списков, kernel — «маленькая» матрица, фильтр/ядро свёртки.
    
    img_h, img_w = len(image), len(image[0])
    k_h, k_w = len(kernel), len(kernel[0])
    #img_h — количество строк в изображении (len(image)).
    #img_w — количество столбцов в изображении (len(image[0])).
    #k_h — количество строк в ядре.
    #k_w — количество столбцов в ядре.

    # размер результата = (h - k_h + 1) × (w - k_w + 1)
    out_h = img_h - k_h + 1
    out_w = img_w - k_w + 1

    if out_h <= 0 or out_w <= 0: #Проверка: если хотя бы одно измерение результата ≤ 0, значит ядро не помещается (оно больше изображения), свёртка невозможна
        raise ValueError("Ядро больше изображения")

    result = [[0 for _ in range(out_w)] for _ in range(out_h)] #Создаём матрицу result размера out_h × out_w, заполненную нулями
    
    #перебирают каждую позицию в результирующей матрице
    for i in range(out_h): #i — индекс строки в результате.
        for j in range(out_w): #j — индекс столбца в результате.
            
            #Для каждой позиции (i, j) мы проходим по всем элементам ядра.
            s = 0
            for ki in range(k_h): #ki — индекс строки в ядре.
                for kj in range(k_w): #kj — индекс столбца в ядре.
                    s += image[i+ki][j+kj] * kernel[ki][kj] #Умножаем и накапливаем сумму s — это скалярное произведение окна изображения и ядра.
            result[i][j] = s
    return result

       


def write_matrix_to_file(matrix):
    # аналогично формируем путь к выходному файлу
    script_dir = os.path.dirname(os.path.abspath(__file__))
    output_path = os.path.join(script_dir, 'matrix_output.txt')
    with open(output_path, 'w', encoding='utf-8') as file:
        for row in matrix: #Перебираем каждую строку матрицы (каждая строка — список чисел)
            file.write(' '.join(map(str, row)) + '\n') #каждое число в row превращаем в строку (иначе join не сможет их соединить).
            #склеиваем элементы списка в одну строку с пробелом между ними.

def main():
    image, kernel = read_matrices_from_file()
    result = convolution_operation(image, kernel)
    write_matrix_to_file(result)

if __name__ == "__main__":
    main()